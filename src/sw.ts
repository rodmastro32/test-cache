/// <reference lib="webworker" />

import { clientsClaim } from "workbox-core";
import { cleanupOutdatedCaches } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { CacheFirst, StaleWhileRevalidate } from "workbox-strategies";
import { CacheableResponsePlugin } from "workbox-cacheable-response";

declare const self: ServiceWorkerGlobalScope;

// Store the webview path and other params
let webviewPath: string | null = null;

// Add a very visible log at the very start
console.log(
  "%c Service Worker Starting ⚙️",
  "background: #222; color: #bada55; font-size: 20px; padding: 10px;"
);

// Take control of all pages immediately
self.skipWaiting();
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by the build process
// precacheAndRoute(self.__WB_MANIFEST);

// Request initial parameters from the client
self.clients.matchAll().then((clients) => {
  console.log(
    "%c Service Worker: Found clients:",
    "background: #222; color: #bada55; font-size: 16px;",
    clients.length
  );
  clients.forEach((client) => {
    client.postMessage({ type: "GET_SW_PARAMS" });
  });
});

console.log(
  "%c Service Worker: Initialization complete ✅",
  "background: #222; color: #bada55; font-size: 16px;"
);

// Log all requests
self.addEventListener("fetch", (event) => {
  console.log(
    "%c Service Worker: Intercepted request:",
    "background: #222; color: #bada55; font-size: 16px;",
    {
      url: event.request.url,
      method: event.request.method,
      mode: event.request.mode,
      destination: event.request.destination,
      headers: Object.fromEntries(event.request.headers.entries()),
    }
  );
});

// Custom handler for JS and CSS files
const handleJSAndCSSFiles = async ({
  request,
  url,
}: {
  request: Request;
  url: URL;
}): Promise<Response> => {
  console.log(
    "%c Service Worker: Handling request for:",
    "background: #222; color: #bada55; font-size: 16px;",
    {
      url: url.toString(),
      method: request.method,
      mode: request.mode,
      destination: request.destination,
      webviewPath: webviewPath,
    }
  );

  // Cache strategy: Use cache first, but update cache in the background
  const cacheName = "js-css-cache";
  console.log(
    "%c Service Worker: Opening cache:",
    "background: #222; color: #bada55; font-size: 16px;",
    cacheName
  );
  const cache = await caches.open(cacheName);

  // Check if we have a cached response
  const cachedResponse = await cache.match(request);

  console.log(
    "%c Service Worker: Cache match result:",
    "background: #222; color: #bada55; font-size: 16px;",
    cachedResponse ? "Found" : "Not found"
  );

  // Start the network request in the background
  console.log(
    "%c Service Worker: Starting network request",
    "background: #222; color: #bada55; font-size: 16px;"
  );
  const networkPromise = fetch(request)
    .then((response) => {
      console.log(
        "%c Service Worker: Network request successful",
        "background: #222; color: #bada55; font-size: 16px;"
      );
      // Clone the response before putting it in the cache
      const responseToCache = response.clone();
      cache.put(request, responseToCache);
      console.log(
        "%c Service Worker: Updated cache with new response",
        "background: #222; color: #bada55; font-size: 16px;"
      );
      return response;
    })
    .catch((error) => {
      console.error(
        "%c Service Worker: Network request failed:",
        "background: #222; color: #ff4444; font-size: 16px;",
        error
      );
      // If we have a cached response, we'll return it below
      // If not, this will propagate the error
      if (!cachedResponse) throw error;
      console.log(
        "%c Service Worker: Falling back to cached response",
        "background: #222; color: #bada55; font-size: 16px;"
      );
      return cachedResponse;
    });

  // If we have a cached response, return it immediately
  if (cachedResponse) {
    console.log(
      "%c Service Worker: Returning cached response immediately",
      "background: #222; color: #bada55; font-size: 16px;"
    );
    // Still update the cache in the background
    networkPromise.catch(() =>
      console.log(
        "%c Service Worker: Background cache update failed",
        "background: #222; color: #ff4444; font-size: 16px;"
      )
    );
    return cachedResponse;
  }

  // If no cached response, wait for the network
  console.log(
    "%c Service Worker: No cache found, waiting for network response",
    "background: #222; color: #bada55; font-size: 16px;"
  );
  return networkPromise;
};

// Register route for JS files
registerRoute(
  ({ request }) => request.destination === "script",
  handleJSAndCSSFiles
);
console.log(
  "%c Service Worker: Registered route for script files",
  "background: #222; color: #bada55; font-size: 16px;"
);

// Register route for CSS files
registerRoute(
  ({ request }) => request.destination === "style",
  handleJSAndCSSFiles
);
console.log(
  "%c Service Worker: Registered route for style files",
  webviewPath,
  "background: #222; color: #bada55; font-size: 16px;"
);

// Cache images with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === "image",
  new CacheFirst({
    cacheName: "images-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);
console.log(
  "%c Service Worker: Registered route for image files",
  "background: #222; color: #bada55; font-size: 16px;"
);

// Handle navigation requests with StaleWhileRevalidate strategy
registerRoute(
  ({ request }) => request.mode === "navigate",
  new StaleWhileRevalidate({
    cacheName: "pages-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);
console.log(
  "%c Service Worker: Registered route for navigation requests",
  "background: #222; color: #bada55; font-size: 16px;"
);
// From your service worker:
self.addEventListener("install", () => {
  const selfUrl = new URL(self.location.href);
  const initialPath = selfUrl.searchParams.get("_param");
  if (initialPath) {
    webviewPath = decodeURIComponent(initialPath);
    console.log(
      "%c Service Worker: Initial path from URL:",
      "background: #222; color: #bada55; font-size: 16px;",
      webviewPath
    );
  }
});

// Handle messages from the client
self.addEventListener("message", (event) => {
  console.log(
    "%c Service Worker: Received message:",
    "background: #222; color: #bada55; font-size: 16px;",
    event.data
  );

  if (event.data && event.data.type === "SKIP_WAITING") {
    console.log(
      "%c Service Worker: Skipping waiting",
      "background: #222; color: #bada55; font-size: 16px;"
    );
    self.skipWaiting();
  }

  // // Handle WebView path updates
  // if (event.data && event.data.type === "SET_WEBVIEW_PATH") {
  //   webviewPath = event.data.path;
  //   console.log("Service Worker: Updated WebView path:", webviewPath);
  // }

  // // Handle initial params
  // if (event.data && event.data.type === "SET_PARAMS") {
  //   const params: ServiceWorkerParams = event.data.params;
  //   if (params.webviewPath) webviewPath = params.webviewPath;
  //   console.log("Service Worker: Updated params:", {
  //     webviewPath,
  //     debug,
  //     cacheConfig,
  //   });
  // }
});
